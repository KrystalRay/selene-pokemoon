// Copyright 2025 International Digital Economy Academy
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

///|
// æŠ€èƒ½ç»“æž„
struct Skill {
  id: String
  name: String
  power: Int
  accuracy: Int
  pp: Int
  max_pp: Int
  type: String
  category: String
}

///|
// æŠ€èƒ½èœå•ç»“æž„
struct SkillMenu {
  mut visible: Bool
  mut selected_index: Int
  mut skills: Array[Skill]
  mut entities: Array[@system.Entity]
  mut background_entity: Option[@system.Entity]
  mut title_entity: Option[@system.Entity]
  
  // å‡ ä½•å±žæ€§
  position: @math.Vec2D
  width: Double
  height: Double
  
  // æŠ€èƒ½å®žä½“
  mut skill_entities: Array[@system.Entity]
  mut skill_text_entities: Array[@system.Entity]
}

///|
// å…¨å±€æŠ€èƒ½èœå•å®žä¾‹
let skill_menu: SkillMenu = {
  visible: false,
  selected_index: 0,
  skills: Array::new(),
  entities: Array::new(),
  background_entity: None,
  title_entity: None,
  position: @math.Vec2D(300, 200),
  width: 200.0,
  height: 150.0,
  skill_entities: Array::new(),
  skill_text_entities: Array::new(),
}

///|
// æ˜¾ç¤ºæŠ€èƒ½èœå•
fn show_skill_menu() -> Unit {
  if skill_menu.visible {
    return
  }
  
  skill_menu.visible = true
  
  // åˆ›å»ºèƒŒæ™¯
  create_skill_menu_background()
  
  // åˆ›å»ºæ ‡é¢˜
  create_skill_menu_title()
  
  // åˆ›å»ºæŠ€èƒ½åˆ—è¡¨
  create_skill_list()
  
  println("âš”ï¸ æŠ€èƒ½èœå•å·²æ˜¾ç¤º")
}

///|
// éšè—æŠ€èƒ½èœå•
fn hide_skill_menu() -> Unit {
  if !skill_menu.visible {
    return
  }
  
  skill_menu.visible = false
  
  // æ¸…ç†æ‰€æœ‰å®žä½“
  for entity in skill_menu.entities {
    @system.Entity::destroy(entity)
  }
  skill_menu.entities.clear()
  
  // æ¸…ç†æŠ€èƒ½å®žä½“
  skill_menu.skill_entities.clear()
  skill_menu.skill_text_entities.clear()
  
  // é‡ç½®é€‰æ‹©
  skill_menu.selected_index = 0
  
  println("âš”ï¸ æŠ€èƒ½èœå•å·²éšè—")
}

///|
// åˆ›å»ºæŠ€èƒ½èœå•èƒŒæ™¯
fn create_skill_menu_background() -> Unit {
  let background = @system.Entity::new()
  @position.positions.set(background, skill_menu.position)
  
  let background_sprite = @sprite.Sprite::new_picture(
    @sprite.Picture::new(
      @math.Vec2D(skill_menu.width, skill_menu.height),
      "pixel_adventure/Menu/Buttons/Play.png",
    ),
    200,
  )
  @sprite.sprites.set(background, background_sprite)
  @ui.uis.set(background, @ui.Ui::new())
  
  skill_menu.background_entity = Some(background)
  skill_menu.entities.push(background)
}

///|
// åˆ›å»ºæŠ€èƒ½èœå•æ ‡é¢˜
fn create_skill_menu_title() -> Unit {
  let title = @system.Entity::new()
  let title_pos = @math.Vec2D(
    skill_menu.position.x,
    skill_menu.position.y - 30
  )
  @position.positions.set(title, title_pos)
  
  let title_text = @sprite.Sprite::new_text(
    @sprite.Text::new("Choose Move", color="#FFFFFF", font="18px Arial"),
    250
  )
  @sprite.sprites.set(title, title_text)
  @ui.uis.set(title, title_text)
  
  skill_menu.title_entity = Some(title)
  skill_menu.entities.push(title)
}

///|
// åˆ›å»ºæŠ€èƒ½åˆ—è¡¨
fn create_skill_list() -> Unit {
  for (index, skill) in skill_menu.skills.enumerate() {
    create_skill_item(skill, index)
  }
}

///|
// åˆ›å»ºæŠ€èƒ½é¡¹
fn create_skill_item(skill: Skill, index: Int) -> Unit {
  let skill_entity = @system.Entity::new()
  let skill_pos = @math.Vec2D(
    skill_menu.position.x + 10,
    skill_menu.position.y + 10 + (index as Double * 30)
  )
  @position.positions.set(skill_entity, skill_pos)
  
  let skill_sprite = @sprite.Sprite::new_picture(
    @sprite.Picture::new(
      @math.Vec2D(80, 25),
      "pixel_adventure/Menu/Buttons/Play.png",
    ),
    240,
  )
  @sprite.sprites.set(skill_entity, skill_sprite)
  @ui.uis.set(skill_entity, @ui.Ui::new())
  
  // æ·»åŠ ç¢°æ’žæ£€æµ‹
  let skill_area = @collision.Area::new(
    @collision.CollisionShape::Rect(
      size=@math.Vec2D(80.0, 25.0),
      offset=@math.Vec2D::zero(),
    ),
    @collision.CollisionLayer::new(),
    @collision.CollisionMask::empty(),
    monitoring_mouse=true,
  )
  
  skill_area.on_just_released(fn(mouse_button) {
    if mouse_button == @system.MouseButton::Left {
      handle_skill_selection(index)
    }
  })
  
  @collision.areas.set(skill_entity, skill_area)
  skill_menu.skill_entities.push(skill_entity)
  skill_menu.entities.push(skill_entity)
  
  // åˆ›å»ºæŠ€èƒ½æ–‡æœ¬
  create_skill_text(skill, index)
}

///|
// åˆ›å»ºæŠ€èƒ½æ–‡æœ¬
fn create_skill_text(skill: Skill, index: Int) -> Unit {
  let text_entity = @system.Entity::new()
  let text_pos = @math.Vec2D(
    skill_menu.position.x + 15,
    skill_menu.position.y + 15 + (index as Double * 30)
  )
  @position.positions.set(text_entity, text_pos)
  
  let skill_text = @sprite.Sprite::new_text(
    @sprite.Text::new(skill.name, color="#FFFFFF", font="14px Arial"),
    250
  )
  @sprite.sprites.set(text_entity, skill_text)
  @ui.uis.set(text_entity, @ui.Ui::new())
  
  skill_menu.skill_text_entities.push(text_entity)
  skill_menu.entities.push(text_entity)
}

///|
// å¤„ç†æŠ€èƒ½é€‰æ‹©
fn handle_skill_selection(index: Int) -> Unit {
  if index >= 0 && index < skill_menu.skills.length() {
    skill_menu.selected_index = index
    let skill = skill_menu.skills[index]
    println("âš”ï¸ é€‰æ‹©äº†æŠ€èƒ½: \(skill.name)")
    
    // éšè—æŠ€èƒ½èœå•
    hide_skill_menu()
    
    // è¿™é‡Œå¯ä»¥è§¦å‘æŠ€èƒ½ä½¿ç”¨é€»è¾‘
    use_skill(skill)
  }
}

///|
// ä½¿ç”¨æŠ€èƒ½
fn use_skill(skill: Skill) -> Unit {
  println("ðŸ”¥ ä½¿ç”¨æŠ€èƒ½: \(skill.name)")
  // è¿™é‡Œå¯ä»¥æ·»åŠ æŠ€èƒ½ä½¿ç”¨çš„å…·ä½“é€»è¾‘
}

///|
// è®¾ç½®æŠ€èƒ½åˆ—è¡¨
fn set_skills(skills: Array[Skill]) -> Unit {
  skill_menu.skills = skills
  skill_menu.selected_index = 0
}

///|
// æ·»åŠ æŠ€èƒ½
fn add_skill(skill: Skill) -> Unit {
  skill_menu.skills.push(skill)
}

///|
// å¤„ç†æŠ€èƒ½èœå•è¾“å…¥
fn handle_skill_menu_input(key: String) -> Unit {
  if !skill_menu.visible {
    return
  }
  
  match key {
    "ArrowUp" => {
      if skill_menu.selected_index > 0 {
        skill_menu.selected_index = skill_menu.selected_index - 1
        update_skill_selection()
      }
    }
    "ArrowDown" => {
      if skill_menu.selected_index < skill_menu.skills.length() - 1 {
        skill_menu.selected_index = skill_menu.selected_index + 1
        update_skill_selection()
      }
    }
    "Enter" | "Space" => {
      confirm_skill_selection()
    }
    "Escape" => {
      hide_skill_menu()
    }
    _ => {}
  }
}

///|
// æ›´æ–°æŠ€èƒ½é€‰æ‹©
fn update_skill_selection() -> Unit {
  // è¿™é‡Œå¯ä»¥æ·»åŠ é€‰æ‹©æŒ‡ç¤ºå™¨çš„æ›´æ–°é€»è¾‘
  println("ðŸ“ é€‰æ‹©äº†æŠ€èƒ½: \(skill_menu.skills[skill_menu.selected_index].name)")
}

///|
// ç¡®è®¤æŠ€èƒ½é€‰æ‹©
fn confirm_skill_selection() -> Unit {
  handle_skill_selection(skill_menu.selected_index)
}

///|
// æ£€æŸ¥æŠ€èƒ½èœå•æ˜¯å¦å¯è§
fn is_skill_menu_visible() -> Bool {
  skill_menu.visible
}

///|
// èŽ·å–é€‰ä¸­çš„æŠ€èƒ½
fn get_selected_skill() -> Option[Skill] {
  if skill_menu.selected_index >= 0 && skill_menu.selected_index < skill_menu.skills.length() {
    Some(skill_menu.skills[skill_menu.selected_index])
  } else {
    None
  }
}

///|
// èŽ·å–æŠ€èƒ½æ•°é‡
fn get_skill_count() -> Int {
  skill_menu.skills.length()
} 